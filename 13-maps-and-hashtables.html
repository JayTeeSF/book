<html class="js flexbox fontface" lang="en" style=""><head><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real World OCaml</title><link rel="stylesheet" href="css/app.css"/><link rel="stylesheet" href="css/prism.css"/><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a href="toc.html" class="to-chapter"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body">
    <section xmlns="http://www.w3.org/1999/xhtml" id="maps-and-hash-tables" data-type="chapter">
      <h1>Maps and Hash Tables</h1>

      <p>
	Lots of programming problems require dealing with data
	organized as key/value pairs. Maybe the simplest way of
	representing such data in OCaml is an <em>association
	  list</em>, which is simply a list of pairs of keys and values.
	For example, you could represent a mapping between the 10
	digits and their English names as follows:

	<a data-type="indexterm" data-primary="key" data-secondary="value pairs">&nbsp;</a>
	<a data-type="indexterm" data-primary="data structures" data-secondary="key/value pairs">&nbsp;</a>
	<a data-type="indexterm" data-primary="lists" data-secondary="association lists">&nbsp;</a>
	<a data-type="indexterm" data-primary="association lists">&nbsp;</a></p>

      <div class="highlight"><pre><code class="language-ocaml"># open Core_kernel;;</code></pre><pre><code class="language-ocaml"># let digit_alist =
    [ 0, "zero"; 1, "one"; 2, "two"  ; 3, "three"; 4, "four"
    ; 5, "five"; 6, "six"; 7, "seven"; 8, "eight"; 9, "nine" ]
  ;;</code></pre><pre class="ge"><code class="language-ocaml">
val digit_alist : (int * string) list =
  [(0, "zero"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
   (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
</code></pre></div>

      <p>
	We can use functions from the <code>List.Assoc</code> module
	to manipulate this data:</p>

      <div class="highlight"><pre><code class="language-ocaml"># List.Assoc.find ~equal:Int.equal digit_alist 6;;</code></pre><pre class="ge"><code class="language-ocaml">- : string option = Some "six"</code></pre><pre><code class="language-ocaml"># List.Assoc.find ~equal:Int.equal digit_alist 22;;</code></pre><pre class="ge"><code class="language-ocaml">- : string option = None</code></pre><pre><code class="language-ocaml"># List.Assoc.add ~equal:Int.equal digit_alist 0 "zilch";;</code></pre><pre class="ge"><code class="language-ocaml">
- : (int, string) Base__List.Assoc.t =
[(0, "zilch"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
 (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
</code></pre></div>

      <p>
	Association lists are simple and easy to use, but their
	performance is not ideal, since almost every nontrivial
	operation on an association list requires a linear-time scan of
	the list.</p>

      <p>
	In this chapter, we'll talk about two more efficient
	alternatives to association lists: <em>maps</em> and <em>hash
	  tables</em>. A map is an immutable tree-based data structure
	where most operations take time logarithmic in the size of the
	map, whereas a hash table is a mutable data structure where
	most operations have constant time complexity. We'll describe
	both of these data structures in detail and provide some advice
	as to how to choose between them.
	<a data-type="indexterm" data-primary="hash tables" data-secondary="basics of">&nbsp;</a>
	<a data-type="indexterm" data-primary="maps" data-secondary="basics of">&nbsp;</a></p>

      <section id="maps" data-type="sect1">
	<h1>Maps</h1>

	<p>
	  Let's consider an example of how one might use a map in
	  practice. In <a href="04-files-modules-and-programs.html#files-modules-and-programs" data-type="xref">Chapter 4, Files Modules And Programs</a>, we showed a
	  module <code>Counter</code> for keeping frequency counts on a
	  set of strings. Here's the interface:</p>

	<div class="highlight"><pre><code class="language-ocaml">open Core_kernel

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(** Converts the set of frequency counts to an association list.
    Every string in the list will show up at most once, and the
    integers will be at least 1. *)
val to_list : t -&gt; (string * int) list</code></pre></div>

	<p>
	  The intended behavior here is straightforward.
	  <code>Counter.empty</code> represents an empty collection of
	  frequency counts; <code>touch</code> increments the frequency
	  count of the specified string by 1; and <code>to_list</code>
	  returns the list of nonzero frequencies.</p>

	<p>Here's the implementation:</p>

	<div class="highlight"><pre><code class="language-ocaml">open Core_kernel

type t = int String.Map.t

let empty = String.Map.empty

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t ~key:s ~data:(count + 1)</code></pre></div>

	<p>
	  Note that in some places the preceding code refers to
	  <code>String.Map.t</code>, and in others <code>Map.t</code>.
	  This has to do with the fact that maps are implemented as
	  ordered binary trees, and as such, need a way of comparing
	  keys.</p>

	<p>
	  To deal with this, a map, once created, stores the
	  necessary comparison function within the data structure.
	  Thus, operations like <code>Map.find</code> or
	  <code>Map.add</code> that access the contents of a map or
	  create a new map from an existing one, do so by using the
	  comparison function embedded within the map.</p>

	<p>
	  But in order to get a map in the first place, you need to
	  get your hands on the comparison function somehow. For this
	  reason, modules like <code>String</code> contain a
	  <code>Map</code> submodule that has values like
	  <code>String.Map.empty</code> and
	  <code>String.Map.of_alist</code> that are specialized to
	  strings, and thus have access to a string comparison
	  function. Such a <code>Map</code> submodule is included in
	  every module that satisfies the <code>Comparable.S</code>
	  interface from Core.</p>

	<section id="creating-maps-with-comparators" data-type="sect2">
          <h2>Creating Maps with Comparators</h2>

          <p>
	    The specialized <code>Map</code> submodule is
            convenient, but it's not the only way of creating a
            <code>Map.t</code>. The information required to compare
            values of a given type is wrapped up in a value called a
            <em>comparator</em> that can be used to create maps using
            the <code>Map</code> module directly:

	    <a data-type="indexterm" data-primary="comparators, creating maps with">&nbsp;</a>
	    <a data-type="indexterm" data-primary="Map module" data-secondary="Map.of_alist_exn">&nbsp;</a>
	    <a data-type="indexterm" data-primary="maps" data-secondary="creating with comparators">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml"># let digit_map = Map.of_alist_exn digit_alist ~comparator:Int.comparator;;</code></pre><pre class="ge"><code class="language-ocaml">val digit_map : (int, string, Int.comparator_witness) Map.t = &lt;abstr&gt;</code></pre><pre><code class="language-ocaml"># Map.find digit_map 3;;</code></pre><pre class="ge"><code class="language-ocaml">- : string option = Some "three"</code></pre></div>

          <p>
	    The preceding code uses <code>Map.of_alist_exn</code>,
            which creates a map from an association list, throwing an
            exception if there are duplicate keys in the list.</p>

          <p>
	    The comparator is only required for operations that
            create maps from scratch. Operations that update an
            existing map simply inherit the comparator of the map they
            start with:</p>

          <div class="highlight"><pre><code class="language-ocaml"># let zilch_map = Map.add digit_map ~key:0 ~data:"zilch";;</code></pre><pre class="ge"><code class="language-ocaml">val zilch_map : (int, string, Int.comparator_witness) Map.t = &lt;abstr&gt;</code></pre></div>

          <p>
	    The type <code>Map.t</code> has three type parameters: one
            for the key, one for the value, and one to identify the
            comparator. Indeed, the type <code>'a Int.Map.t</code> is
            just a type alias
            for <code>(int,'a,Int.comparator_witness)
            Map.t</code>.</p>

          <p>
	    Including the comparator in the type is important because
            operations that work on multiple maps at the same time often
            require that the maps share their comparison function.
            Consider, for example, <code>Map.symmetric_diff</code>,
            which computes the difference between two maps.</p>

          <div class="highlight"><pre><code class="language-ocaml"># let left = String.Map.of_alist_exn ["foo",1; "bar",3; "snoo",0];;</code></pre><pre class="ge"><code class="language-ocaml">val left : int String.Map.t = &lt;abstr&gt;</code></pre><pre><code class="language-ocaml"># let right = String.Map.of_alist_exn ["foo",0; "snoo",0];;</code></pre><pre class="ge"><code class="language-ocaml">val right : int String.Map.t = &lt;abstr&gt;</code></pre><pre><code class="language-ocaml"># Map.symmetric_diff ~data_equal:Int.equal left right |&gt; Sequence.to_list;;</code></pre><pre class="ge"><code class="language-ocaml">
- : (string, int) Map.Symmetric_diff_element.t list =
[("bar", `Left 3); ("foo", `Unequal (1, 0))]
</code></pre></div>

          <p>
	    The type of <code>Map.symmetric_diff</code>, which
            follows, requires that the two maps it compares have the
            same comparator type. Each comparator has a distinct
            abstract type, so the type of a comparator identifies the
            comparator uniquely.</p>

          <div class="highlight"><pre><code class="language-ocaml"># Map.symmetric_diff;;</code></pre><pre class="ge"><code class="language-ocaml">
- : ('k, 'v, 'cmp) Map.t -&gt;
    ('k, 'v, 'cmp) Map.t -&gt;
    data_equal:('v -&gt; 'v -&gt; bool) -&gt;
    ('k, 'v) Map.Symmetric_diff_element.t Sequence.t
= &lt;fun&gt;
</code></pre></div>

          <p>
	    This constraint is important because the algorithm
            that <code>Map.symmetric_diff</code> uses depends for its
            correctness on the fact that both maps have the same
            comparator.</p>

          <p>
	    We can create a new comparator using the
            <code>Comparator.Make</code> functor, which takes as its
            input a module containing the type of the object to be
            compared, sexp converter functions, and a comparison
            function. The sexp converters are included in the
            comparator to make it possible for users of the comparator
            to generate better error messages. Here's an
            example:

	    <a data-type="indexterm" data-primary="Sexplib package" data-secondary="sexp converter">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml"># module Reverse = Comparator.Make(struct
      type t = string
      let sexp_of_t = String.sexp_of_t
      let t_of_sexp = String.t_of_sexp
      let compare x y = String.compare y x
    end);;</code></pre><pre class="ge"><code class="language-ocaml">
module Reverse :
  sig
    type comparator_witness
    val comparator : (string, comparator_witness) Comparator.t
  end
</code></pre></div>

          <p>
	    As you can see in the following code,
            both <code>Reverse.comparator_witness</code>
            and <code>String.comparator_witness</code> can be used to
            create maps with a key type of <code>string</code>:</p>

          <div class="highlight"><pre><code class="language-ocaml"># let alist = ["foo", 0; "snoo", 3];;</code></pre><pre class="ge"><code class="language-ocaml">val alist : (string * int) list = [("foo", 0); ("snoo", 3)]</code></pre><pre><code class="language-ocaml"># let ord_map = Map.of_alist_exn ~comparator:String.comparator alist;;</code></pre><pre class="ge"><code class="language-ocaml">val ord_map : (string, int, String.comparator_witness) Map.t = &lt;abstr&gt;</code></pre><pre><code class="language-ocaml"># let rev_map = Map.of_alist_exn ~comparator:Reverse.comparator alist;;</code></pre><pre class="ge"><code class="language-ocaml">val rev_map : (string, int, Reverse.comparator_witness) Map.t = &lt;abstr&gt;</code></pre></div>

          <p>
	    <code>Map.min_elt</code> returns the key and value for
            the smallest key in the map, which lets us see that these
            two maps do indeed use different comparison functions:</p>

          <div class="highlight"><pre><code class="language-ocaml"># Map.min_elt ord_map;;</code></pre><pre class="ge"><code class="language-ocaml">- : (string * int) option = Some ("foo", 0)</code></pre><pre><code class="language-ocaml"># Map.min_elt rev_map;;</code></pre><pre class="ge"><code class="language-ocaml">- : (string * int) option = Some ("snoo", 3)</code></pre></div>

          <p>
	    Accordingly, if we try to use
            <code>Map.symmetric_diff</code> on these two maps, we'll
            get a compile-time error:</p>

          <div class="highlight"><pre><code class="language-ocaml"># Map.symmetric_diff ord_map rev_map;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 27-34:
Error: This expression has type
         (string, int, Reverse.comparator_witness) Map.t
       but an expression was expected of type
         (string, int, String.comparator_witness) Map.t
       Type Reverse.comparator_witness is not compatible with type
         String.comparator_witness 
</code></pre></div>
	</section>

	<section id="trees" data-type="sect2">
          <h2>Trees</h2>

          <p>
	    As we've discussed, maps carry within them the comparator
            that they were created with. Sometimes, for space
            efficiency reasons, you want a version of the map data
            structure that doesn't include the comparator. You can get
            such a representation with <code>Map.to_tree</code>, which
            returns just the tree underlying the map, without the
            comparator:

	    <a data-type="indexterm" data-primary="Map module" data-secondary="Map.to_tree">&nbsp;</a>
	    <a data-type="indexterm" data-primary="maps" data-secondary="tree structure">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml"># let ord_tree = Map.to_tree ord_map;;</code></pre><pre class="ge"><code class="language-ocaml">val ord_tree : (string, int, String.comparator_witness) Map.Tree.t = &lt;abstr&gt;</code></pre></div>

          <p>
	    Even though a <code>Map.Tree.t</code> doesn't physically
            include a comparator, it does include the comparator in its
            type. This is what is known as a <em>phantom type</em>,
            because it reflects something about the logic of the value
            in question, even though it doesn't correspond to any
            values directly represented in the underlying physical
            structure of the value.</p>

          <p>
	    Since the comparator isn't included in the tree, we need
            to provide the comparator explicitly when we, say, search
            for a key, as shown below:</p>

          <div class="highlight"><pre><code class="language-ocaml"># Map.Tree.find ~comparator:String.comparator ord_tree "snoo";;</code></pre><pre class="ge"><code class="language-ocaml">- : int option = Some 3</code></pre></div>

          <p>
	    The algorithm of <code>Map.Tree.find</code> depends on
            the fact that it's using the same comparator when looking
            up a value as you were when you stored it. That's the
            invariant that the phantom type is there to enforce. As you
            can see in the following example, using the wrong
            comparator will lead to a type error:</p>

          <div class="highlight"><pre><code class="language-ocaml"># Map.Tree.find ~comparator:Reverse.comparator ord_tree "snoo";;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 45-53:
Error: This expression has type
         (string, int, String.comparator_witness) Map.Tree.t
       but an expression was expected of type
         (string, int, Reverse.comparator_witness) Map.Tree.t
       Type String.comparator_witness is not compatible with type
         Reverse.comparator_witness 
</code></pre></div>
	</section>

	<section id="the-polymorphic-comparator" data-type="sect2">
          <h2>The Polymorphic Comparator</h2>

          <p>
	    We don't need to generate specialized comparators for
            every type we want to build a map on. We can instead use a
            comparator based on OCaml's built-in polymorphic comparison
            function, which was discussed in <a href="03-lists-and-patterns.html#lists-and-patterns" data-type="xref">Chapter 3, Lists And Patterns</a>. This comparator is found in
            the <code>Comparator.Poly</code> module, allowing us to
            write:

	    <a data-type="indexterm" data-primary="maps" data-secondary="polymorphic comparison in">&nbsp;</a>
	    <a data-type="indexterm" data-primary="Comparator.Poly module">&nbsp;</a>
	    <a data-type="indexterm" data-primary="polymorphic comparisons">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml"># Map.of_alist_exn ~comparator:Comparator.Poly.comparator digit_alist;;</code></pre><pre class="ge"><code class="language-ocaml">- : (int, string, Comparator.Poly.comparator_witness) Map.t = &lt;abstr&gt;</code></pre></div>

          <p>
	    Or, equivalently:</p>

          <div class="highlight"><pre><code class="language-ocaml"># Map.Poly.of_alist_exn digit_alist;;</code></pre><pre class="ge"><code class="language-ocaml">- : (int, string) Map.Poly.t = &lt;abstr&gt;</code></pre></div>

          <p>
	    Note that maps based on the polymorphic comparator are
            not equivalent to those based on the type-specific
            comparators from the point of view of the type system.
            Thus, the compiler rejects the following:</p>

          <div class="highlight"><pre><code class="language-ocaml"># Map.symmetric_diff
    (Map.Poly.singleton 3 "three")
    (Int.Map.singleton  3 "four" )
  ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 54-84:
Error: This expression has type
         string Int.Map.t = (int, string, Int.comparator_witness) Map.t
       but an expression was expected of type
         (int, string, Comparator.Poly.comparator_witness) Map.t
       Type Int.comparator_witness is not compatible with type
         Comparator.Poly.comparator_witness 
</code></pre></div>

          <p>
	    This is rejected for good reason: there's no guarantee
            that the comparator associated with a given type will order
            things in the same way that polymorphic compare does.</p>

          <aside data-type="sidebar">
            <h5>The Perils of Polymorphic Compare</h5>

            <p>
	      Polymorphic compare is highly convenient, but it has
              serious downsides as well and should be used with care.
              In particular, polymorphic compare has a fixed algorithm
              for comparing values of any type, and that algorithm can
              sometimes yield surprising results.</p>

            <p>
	      To understand what's wrong with polymorphic compare,
              you need to understand a bit about how it works.
              Polymorphic compare is <em>structural</em>, in that it
              operates directly on the runtime representation of OCaml
              values, walking the structure of the values in question
              without regard for their type.</p>

            <p>
	      This is convenient because it provides a comparison
              function that works for most OCaml values and largely
              behaves as you would expect. For example,
              on <code>int</code>s and <code>float</code>s, it acts as
              you would expect a numeric comparison function to
              act. For simple containers like strings and lists and
              arrays, it operates as a lexicographic comparison. And
              except for values from outside of the OCaml heap and
              functions, it works on almost every OCaml type.</p>

            <p>
	      But sometimes, a structural comparison is not what you
              want. Sets are a great example of this. Consider the
              following two sets:</p>

            <div class="highlight"><pre><code class="language-ocaml"># let s1 = Int.Set.of_list [1;2];;</code></pre><pre class="ge"><code class="language-ocaml">val s1 : Int.Set.t = &lt;abstr&gt;</code></pre><pre><code class="language-ocaml"># let s2 = Int.Set.of_list [2;1];;</code></pre><pre class="ge"><code class="language-ocaml">val s2 : Int.Set.t = &lt;abstr&gt;</code></pre></div>

            <p>
	      Logically, these two sets should be equal, and that's
              the result that you get if you call
              <code>Set.equal</code> on them:</p>

            <div class="highlight"><pre><code class="language-ocaml"># Set.equal s1 s2;;</code></pre><pre class="ge"><code class="language-ocaml">- : bool = true</code></pre></div>

            <p>
	      But because the elements were added in different
              orders, the layout of the trees underlying the sets will
              be different. As such, a structural comparison function
              will conclude that they're different.</p>

            <p>
	      Let's see what happens if we use polymorphic compare
              to test for equality by way of the <code>=</code>
              operator. Comparing the maps directly will fail at
              runtime because the comparators stored within the sets
              contain function values:</p>

            <div class="highlight"><pre><code class="language-ocaml"># s1 = s2;;</code></pre><pre class="ge"><code class="language-ocaml">Exception: (Invalid_argument "compare: functional value").</code></pre></div>

            <p>
	      We can, however, use the function
              <code>Set.to_tree</code> to expose the underlying tree
              without the attached comparator:</p>

            <div class="highlight"><pre><code class="language-ocaml"># Set.to_tree s1 = Set.to_tree s2;;</code></pre><pre class="ge"><code class="language-ocaml">- : bool = false</code></pre></div>

            <p>
	      This can cause real and quite subtle bugs. If, for
              example, you use a map whose keys contain sets, then the
              map built with the polymorphic comparator will behave
              incorrectly, separating out keys that should be
              aggregated together. Even worse, it will work sometimes
              and fail others; since if the sets are built in a
              consistent order, then they will work as expected, but
              once the order changes, the behavior will change.</p>
          </aside>
	</section>

	<section id="sets" data-type="sect2">
          <h2>Sets</h2>

          <p>
	    Sometimes, instead of keeping track of a set of key/value
            pairs, you just want to keep track of a set of keys. You
            could representing a set of values by a map whose data
            type is <code>unit</code>. But a more idiomatic (and
            efficient) solution is to use Core's set type, which is
            similar in design and spirit to the map type, while having
            an API better tuned to working with sets and a lower
            memory footprint. Here's a simple example:
	    <a data-type="indexterm" data-primary="set types">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml"># let dedup ~comparator l =
    List.fold l ~init:(Set.empty ~comparator) ~f:Set.add
    |&gt; Set.to_list
  ;;</code></pre><pre class="ge"><code class="language-ocaml">val dedup : comparator:('a, 'b) Comparator.t -&gt; 'a list -&gt; 'a list = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># dedup ~comparator:Int.comparator [8;3;2;3;7;8;10];;</code></pre><pre class="ge"><code class="language-ocaml">- : int list = [2; 3; 7; 8; 10]</code></pre></div>

          <p>
	    In addition to the operators you would expect to have
            for maps, sets support the traditional set operations,
            including union, intersection, and set difference. And, as
            with maps, we can create sets based on type-specific
            comparators or on the polymorphic comparator.</p>
	</section>

	<section id="satisfying-the-comparable.s-interface" data-type="sect2">
          <h2>Satisfying the Comparable.S Interface</h2>

          <p>
	    Core's <code>Comparable.S</code> interface includes a
            lot of useful functionality, including support for working
            with maps and sets. In particular,
            <code>Comparable.S</code> requires the presence of the
            <code>Map</code> and <code>Set</code> submodules, as well
            as a comparator.

	    <a data-type="indexterm" data-primary="interfaces" data-secondary="Comparable.S">&nbsp;</a>
	    <a data-type="indexterm" data-primary="Comparable module" data-secondary="Comparable.Make">&nbsp;</a>
	    <a data-type="indexterm" data-primary="Comparable module" data-secondary="Comparable.S">&nbsp;</a>
	    <a data-type="indexterm" data-primary="maps" data-secondary="comparable.S interface">&nbsp;</a></p>

          <p>
	    <code>Comparable.S</code> is satisfied by most of the
            types in Core, but the question arises of how to satisfy
            the comparable interface for a new type that you design.
            Certainly implementing all of the required functionality
            from scratch would be an absurd amount of work.</p>

          <p>
	    The module <code>Comparable</code> contains a number of
            functors to help you automate this task. The simplest one
            of these is <code>Comparable.Make</code>, which takes as an
            input any module that satisfies the following
            interface:</p>

          <div class="highlight"><pre><code class="language-ocaml">module type Comparable = sig
  type t
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
  val compare : t -&gt; t -&gt; int
end</code></pre></div>

          <p>
	    In other words, it expects a type with a comparison
            function, as well as functions for converting to and
            from <em>s-expressions</em>. S-expressions are a
            serialization format used commonly in Core and are
            required here to enable better error messages. We'll
            discuss s-expressions more
            in <a href="17-data-serialization.html#data-serialization-with-s-expressions" data-type="xref">Chapter 17, Data Serialization With S
            Expressions</a>, but in the meantime, we'll use
            the <code>[@@deriving sexp]</code> annotation that comes
            from the <code>ppx_sexp_conv</code> syntax extension.
            This declaration kicks off the automatic generation of
            s-expression conversion functions for the marked type.</p>

          <p>
	    The following example shows how this all fits together,
            following the same basic pattern for using functors described
            in <a href="09-functors.html#extending-modules" data-type="xref">Chapter 9, Extending Modules</a>:</p>

          <div class="highlight"><pre><code class="language-ocaml"># module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } [@@deriving sexp]
      let compare t1 t2 =
        let c = Int.Set.compare t1.foo t2.foo in
        if c &lt;&gt; 0 then c else String.compare t1.bar t2.bar
    end
    include T
    include Comparable.Make(T)
  end;;</code></pre><pre class="ge"><code class="language-ocaml">
module Foo_and_bar :
  sig
    type t = { foo : Int.Set.t; bar : string; }
    val ( &gt;= ) : t -&gt; t -&gt; bool
    val ( &lt;= ) : t -&gt; t -&gt; bool
    val ( = ) : t -&gt; t -&gt; bool
    val ( &gt; ) : t -&gt; t -&gt; bool
    val ( &lt; ) : t -&gt; t -&gt; bool
    val ( &lt;&gt; ) : t -&gt; t -&gt; bool
    val equal : t -&gt; t -&gt; bool
    val compare : t -&gt; t -&gt; int
...
    module Replace_polymorphic_compare :
      sig
        val ( &gt;= ) : t -&gt; t -&gt; bool
        val ( &lt;= ) : t -&gt; t -&gt; bool
        val ( = ) : t -&gt; t -&gt; bool
        val ( &gt; ) : t -&gt; t -&gt; bool
...
      end
    module Map :
      sig
...
      end
    module Set :
      sig
...
      end
  end
</code></pre></div>

          <p>
	    We don't include the full response from the toplevel
            because it is quite lengthy, but <code>Foo_and_bar</code>
            does satisfy <code>Comparable.S</code>.</p>

          <p>
	    In the preceding code we wrote the comparison function by
            hand, but this isn't strictly necessary. Core ships with a
            syntax extension which will create a comparison function
            from a type definition if you write <code>[@@deriving
            compare]</code> after the type defintion.  We can rewrite
            the previous example to use this extension</p>

          <div class="highlight"><pre><code class="language-ocaml"># module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } [@@deriving sexp, compare]
    end
    include T
    include Comparable.Make(T)
  end;;</code></pre><pre class="ge"><code class="language-ocaml">
module Foo_and_bar :
  sig
    type t = { foo : Int.Set.t; bar : string; }
    val ( &gt;= ) : t -&gt; t -&gt; bool
    val ( &lt;= ) : t -&gt; t -&gt; bool
    val ( = ) : t -&gt; t -&gt; bool
    val ( &gt; ) : t -&gt; t -&gt; bool
...
  end
</code></pre></div>

          <p>
	    The comparison function we get from <code>[@@deriving
	    compare]</code> will call out to the comparison functions
	    for its component types. As a result, the <code>foo</code>
	    field will be compared
	    using <code>Int.Set.compare</code>. This is different, and
            saner than the structural comparison done by polymorphic
            compare.</p>

          <p>
	    If you want your comparison function that orders things in
	    a particular way, you can always write your own comparison
            function by hand; but if all you need is a total order
            suitable for creating maps and sets with,
            then <code>[@@deriving compare]</code> is a good
            choice.</p>

          <p>
	    You can also satisfy the <code>Comparable.S</code>
            interface using polymorphic compare:</p>

          <div class="highlight"><pre><code class="language-ocaml"># module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } [@@deriving sexp]
    end
    include T
    include Comparable.Poly(T)
  end;;</code></pre><pre class="ge"><code class="language-ocaml">
module Foo_and_bar :
  sig
    type t = { foo : int; bar : string; }
    val ( &gt;= ) : t -&gt; t -&gt; bool
    val ( &lt;= ) : t -&gt; t -&gt; bool
    val ( = ) : t -&gt; t -&gt; bool
    val ( &gt; ) : t -&gt; t -&gt; bool
    val ( &lt; ) : t -&gt; t -&gt; bool
    val ( &lt;&gt; ) : t -&gt; t -&gt; bool
    val equal : t -&gt; t -&gt; bool
    val compare : t -&gt; t -&gt; int
...
  end
</code></pre></div>

          <p>
	    That said, for reasons we discussed earlier, polymorphic
            compare should be used sparingly.</p>

          <aside data-type="sidebar">
            <h5>=, ==, and phys_equal</h5>

            <p>
	      If you come from a C/C++ background, you'll probably
              reflexively use <code>==</code> to test two values for
              equality. In OCaml, the <code>==</code> operator tests
              for <em>physical</em> equality, while the <code>=</code>
              operator tests for <em>structural</em> equality.</p>

            <p>
	      The physical equality test will match if two data
              structures have precisely the same pointer in memory. Two
              data structures that have identical contents but are
              constructed separately will not match using
              <code>==</code>.</p>

            <p>
	      The <code>=</code> structural equality operator
              recursively inspects each field in the two values and
              tests them individually for equality. Crucially, if your
              data structure is cyclical (that is, a value recursively
              points back to another field within the same structure),
              the <code>=</code> operator will never terminate, and
              your program will hang! You therefore must use the
              physical equality operator or write a custom comparison
              function when comparing cyclic values.</p>

            <p>
	      It's quite easy to mix up the use of <code>=</code>
              and <code>==</code>, so Core_kernel discourages the use
              of <code>==</code> and provides the more
              explicit <code>phys_equal</code> function
              instead. You'll see a warning if you use <code>==</code>
              anywhere in code that
              opens <code>Core_kernel</code>:</p>

            <div class="highlight"><pre><code class="language-ocaml"># open Core_kernel;;</code></pre><pre><code class="language-ocaml"># 1 == 2 ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 2-4:
Warning 3: deprecated: Core_kernel.==
[since 2014-10] Use [phys_equal]
</code></pre><pre class="ge"><code class="language-ocaml">- : bool = false</code></pre><pre><code class="language-ocaml"># phys_equal 1 2 ;;</code></pre><pre class="ge"><code class="language-ocaml">- : bool = false</code></pre></div>

            <p>
	      If you feel like hanging your OCaml interpreter, you
              can verify what happens with recursive values and
              structural equality for yourself:</p>

            <div class="highlight"><pre><code class="language-ocaml"># type t1 = { foo1:int; bar1:t2 } and t2 = { foo2:int; bar2:t1 } ;;
type t1 = { foo1 : int; bar1 : t2; }
and t2 = { foo2 : int; bar2 : t1; }
# let rec v1 = { foo1=1; bar1=v2 } and v2 = { foo2=2; bar2=v1 } ;;
&lt;lots of text&gt;
# v1 == v1;;
- : bool = true
# phys_equal v1 v1;;
- : bool = true
# v1 = v1 ;;
&lt;press ^Z and kill the process now&gt;
</code></pre></div>
          </aside>
	</section>
      </section>

      <section id="hash-tables" data-type="sect1">
	<h1>Hash Tables</h1>

	<p>
	  Hash tables are the imperative cousin of maps. We walked
	  over a basic hash table implementation in <a href="08-imperative-programming.html#imperative-programming-1" data-type="xref">Chapter 8, Imperative Programming 1</a>, so in this
	  section we'll mostly discuss the pragmatics of Core's
	  <code>Hashtbl</code> module. We'll cover this material more
	  briefly than we did with maps because many of the concepts
	  are shared.

	  <a data-type="indexterm" data-primary="hash tables" data-secondary="basics of">&nbsp;</a></p>

	<p>
	  Hash tables differ from maps in a few key ways. First,
	  hash tables are mutable, meaning that adding a key/value pair
	  to a hash table modifies the table, rather than creating a
	  new table with the binding added. Second, hash tables
	  generally have better time-complexity than maps, providing
	  constant-time lookup and modifications, as opposed to
	  logarithmic for maps. And finally, just as maps depend on
	  having a comparison function for creating the ordered binary
	  tree that underlies a map, hash tables depend on having a
	  <em>hash function</em>, i.e., a function for converting a key
	  to an integer.

	  <a data-type="indexterm" data-primary="functions" data-secondary="hash functions">&nbsp;</a>
	  <a data-type="indexterm" data-primary="Hashtbl module">&nbsp;</a>
	  <a data-type="indexterm" data-primary="hash tables" data-secondary="time complexity of">&nbsp;</a></p>

	<div class="allow_break" data-type="warning">
          <h1>Time Complexity of Hash Tables</h1>

          <p>
	    The statement that hash tables provide constant-time
            access hides some complexities. First of all, any hash
            table implementation, OCaml's included, needs to resize the
            table when it gets too full. A resize requires allocating a
            new backing array for the hash table and copying over all
            entries, and so it is quite an expensive operation. That
            means adding a new element to the table is only
            <em>amortized</em> constant, which is to say, it's constant
            on average over a long sequence of operations, but some of
            the individual operations can be quite expensive.</p>

          <p>
	    Another hidden cost of hash tables has to do with the
            hash function you use. If you end up with a pathologically
            bad hash function that hashes all of your data to the same
            number, then all of your insertions will hash to the same
            underlying bucket, meaning you no longer get constant-time
            access at all. Core's hash table implementation uses binary
            trees for the hash-buckets, so this case only leads to
            logarithmic time, rather than linear for a traditional hash
            table.</p>

          <p>
	    The logarithmic behavior of Core's hash tables in the
            presence of hash collisions also helps protect against some
            denial-of-service attacks. One well-known type of attack is
            to send queries to a service with carefully chosen keys to
            cause many collisions. This, in combination with the linear
            behavior of most hashtables, can cause the service to
            become unresponsive due to high CPU load. Core's hash
            tables would be much less susceptible to such an attack
            because the amount of degradation would be far less.

	    <a data-type="indexterm" data-primary="security issues" data-secondary="denial-of-service attacks">&nbsp;</a>
	    <a data-type="indexterm" data-primary="denial-of-service attacks, avoiding">&nbsp;</a></p>
	</div>

	<p>
	  When creating a hash table, we need to provide a value of
	  type <em>hashable</em>, which includes among other things the
	  function for hashing the key type. This is analogous to the
	  comparator used for creating maps:</p>

	<div class="highlight"><pre><code class="language-ocaml"># let table = Hashtbl.create ~hashable:String.hashable ();;</code></pre><pre class="ge"><code class="language-ocaml">val table : (string, '_a) Hashtbl.t = &lt;abstr&gt;</code></pre><pre><code class="language-ocaml"># Hashtbl.set table ~key:"three" ~data:3;;</code></pre><pre class="ge"><code class="language-ocaml">- : unit = ()</code></pre><pre><code class="language-ocaml"># Hashtbl.find table "three";;</code></pre><pre class="ge"><code class="language-ocaml">- : int option = Some 3</code></pre></div>

	<p>
	  The <code>hashable</code> value is included as part of the
	  <code>Hashable.S</code> interface, which is satisfied by most
	  types in Core. The <code>Hashable.S</code> interface also
	  includes a <code>Table</code> submodule which provides more
	  convenient creation functions:</p>

	<div class="highlight"><pre><code class="language-ocaml"># let table = String.Table.create ();;</code></pre><pre class="ge"><code class="language-ocaml">val table : '_a String.Table.t = &lt;abstr&gt;</code></pre></div>

	<p>
	  There is also a polymorphic <code>hashable</code> value,
	  corresponding to the polymorphic hash function provided by
	  the OCaml runtime, for cases where you don't have a hash
	  function for your specific type:</p>

	<div class="highlight"><pre><code class="language-ocaml"># let table = Hashtbl.create ~hashable:Hashtbl.Poly.hashable ();;</code></pre><pre class="ge"><code class="language-ocaml">val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;</code></pre></div>

	<p>
	  Or, equivalently:</p>

	<div class="highlight"><pre><code class="language-ocaml"># let table = Hashtbl.Poly.create ();;</code></pre><pre class="ge"><code class="language-ocaml">val table : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;</code></pre></div>

	<p>
	  Note that, unlike the comparators used with maps and sets,
	  hashables don't show up in the type of a
	  <code>Hashtbl.t</code>. That's because hash tables don't have
	  operations that operate on multiple hash tables that depend
	  on those tables having the same hash function, in the way
	  that <code>Map.symmetric_diff</code> and
	  <code>Set.union</code> depend on their arguments using the
	  same comparison function.

	  <a data-type="indexterm" data-primary="polymorphism" data-secondary="in hash functions">&nbsp;</a></p>

	<div data-type="warning">
          <h1>Collisions with the Polymorphic Hash Function</h1>

          <p>
	    OCaml's polymorphic hash function works by walking over
            the data structure it’s given using a breadth-first
            traversal that is bounded in the number of nodes it’s
            willing to traverse. By default, that bound is set at 10
            "meaningful" nodes.

	    <a data-type="indexterm" data-primary="hash tables" data-secondary="polymorphic hash function">&nbsp;</a></p>

          <p>
	    The bound on the traversal means that the hash function
            may ignore part of the data structure, and this can lead to
            pathological <span class="keep-together">cases</span> where
            every value you store has the same hash value. We'll
            demonstrate this below, using the function
            <code>List.range</code> to allocate lists of integers of
            different length:</p>
	</div>

	<div class="highlight"><pre><code class="language-ocaml"># Caml.Hashtbl.hash (List.range 0 9);;</code></pre><pre class="ge"><code class="language-ocaml">- : int = 209331808</code></pre><pre><code class="language-ocaml"># Caml.Hashtbl.hash (List.range 0 10);;</code></pre><pre class="ge"><code class="language-ocaml">- : int = 182325193</code></pre><pre><code class="language-ocaml"># Caml.Hashtbl.hash (List.range 0 11);;</code></pre><pre class="ge"><code class="language-ocaml">- : int = 182325193</code></pre><pre><code class="language-ocaml"># Caml.Hashtbl.hash (List.range 0 100);;</code></pre><pre class="ge"><code class="language-ocaml">- : int = 182325193</code></pre></div>

	<p>
	  As you can see, the hash function stops after the first 10
	  elements. The same can happen with any large data structure,
	  including records and arrays. When building hash functions
	  over large custom data structures, it is generally a good
	  idea to write one's own hash function.</p>

	<section id="satisfying-the-hashable.s-interface" data-type="sect2">
          <h2>Satisfying the Hashable.S Interface</h2>

          <p>
	    Most types in Core satisfy the <code>Hashable.S</code>
            interface, but as with the <code>Comparable.S</code>
            interface, the question remains of how one should satisfy
            this interface when writing a new module. Again, the
            answer is to use a functor to build the necessary
            functionality; in this case, <code>Hashable.Make</code>,
            using <code>[@@deriving hash]</code> to produce the hash
            function.

	    <a data-type="indexterm" data-primary="Hashable.Make">&nbsp;</a>
	    <a data-type="indexterm" data-primary="interfaces" data-secondary="Hashable.S">&nbsp;</a>
	    <a data-type="indexterm" data-primary="Hashable.S interface">&nbsp;</a>
	    <a data-type="indexterm" data-primary="hash tables" data-secondary="satisfying Hashable.S interface">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml"># module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Hashable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } [@@deriving sexp, compare, hash]
    end
    include T
    include Hashable.Make(T)
  end;;</code></pre><pre class="ge"><code class="language-ocaml">
module Foo_and_bar :
  sig
    type t = { foo : int; bar : string; }
    val hash : t -&gt; int
    val compare : t -&gt; t -&gt; int
    val hashable : t Hashtbl_intf.Hashable.t
    module Table :
      sig
        type key = t
        type ('a, 'b) hashtbl = ('a, 'b) Hashtbl.t
...
      end
    module Hash_set :
      sig
...
      end
    module Hash_queue :
      sig
...
      end
  end
</code></pre></div>

          <p>
	    Note that in order to satisfy hashable, a key needs to
            provide a comparison function, for equality checking, and
            s-expression conversion, for generating useful errors.</p>

          <p>
	    There is currently no analogue of
            <code>comparelib</code> for autogeneration of hash
            functions, so you do need to either write the hash function
            by hand, or use the built-in polymorphic hash function,
            <code>Hashtbl.hash</code>.</p>
	</section>
      </section>

      <section id="choosing-between-maps-and-hash-tables" data-type="sect1">
	<h1>Choosing Between Maps and Hash Tables</h1>

	<p>
	  Maps and hash tables overlap enough in functionality that
	  it's not always clear when to choose one or the other. Maps,
	  by virtue of being immutable, are generally the default
	  choice in OCaml. OCaml also has good support for imperative
	  programming, though, and when programming in an imperative
	  idiom, hash tables are often the more natural choice.

	  <a data-type="indexterm" data-primary="maps" data-secondary="vs. hashtables">&nbsp;</a>
	  <a data-type="indexterm" data-primary="hash tables" data-secondary="vs. maps">&nbsp;</a></p>

	<p>
	  Programming idioms aside, there are significant
	  performance differences between maps and hash tables. For
	  code that is dominated by updates and lookups, hash tables
	  are a clear performance win, and the win is clearer the
	  larger the amount of data.</p>

	<p>
	  The best way of answering a performance question is by
	  running a benchmark, so let's do just that. The following
	  benchmark uses the <code>core_bench</code> library, and it
	  compares maps and hash tables under a very simple workload.
	  Here, we're keeping track of a set of 1,000 different integer
	  keys and cycling over the keys and updating the values they
	  contain. Note that we use the <code>Map.change</code> and
	  <code>Hashtbl.change</code> functions to update the
	  respective data structures:</p>

	<div class="highlight"><pre><code class="language-ocaml">open Core_kernel
open Core_bench

let map_iter ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0 then ()
    else loop (i - 1)
           (Map.change map (i mod num_keys) ~f:(fun current -&gt;
              Some (1 + Option.value ~default:0 current)))
  in
  loop iterations Int.Map.empty

let table_iter ~num_keys ~iterations =
  let table = Int.Table.create ~size:num_keys () in
  let rec loop i =
    if i &lt;= 0 then ()
    else (
      Hashtbl.change table (i mod num_keys) ~f:(fun current -&gt;
        Some (1 + Option.value ~default:0 current));
      loop (i - 1)
    )
  in
  loop iterations

let tests ~num_keys ~iterations =
  let test name f = Bench.Test.create f ~name in
  [ test "table" (fun () -&gt; table_iter ~num_keys ~iterations)
  ; test "map"   (fun () -&gt; map_iter   ~num_keys ~iterations)
  ]

let () =
  tests ~num_keys:1000 ~iterations:100_000
  |&gt; Bench.make_command
  |&gt; Core.Command.run</code></pre></div>

	<p>
	  The results show the hash table version to be around four
	  times faster than the map version:</p>
  <div class="highlight"><pre><code class="language-ocaml">(executable ((name map_vs_hash) (libraries (core_bench))))
</code></pre></div>
	<div class="highlight"><pre><code class="language-ocaml">$ jbuilder build map_vs_hash.exe
Error: exception Sys_error("jbuild.inc: No such file or directory")
Backtrace:
Raised by primitive operation at file "pervasives.ml", line 389, characters 28-54
Called from file "src/io.ml", line 15, characters 11-31
Called from file "src/jbuild.ml", line 979, characters 22-71
Called from file "src/sexp.ml", line 339, characters 36-48
Called from file "list.ml", line 82, characters 20-23
Called from file "src/import.ml" (inlined), line 68, characters 31-41
Called from file "src/jbuild.ml", line 1005, characters 4-71
Called from file "src/jbuild.ml", line 1009, characters 6-63
Called from file "src/jbuild_load.ml", line 164, characters 33-64
Called from file "src/jbuild_load.ml", line 224, characters 23-44
Called from file "src/jbuild_load.ml", line 234, characters 16-58
Called from file "src/main.ml", line 26, characters 13-56
Called from file "bin/main.ml", line 547, characters 7-29
Called from file "vendor/cmdliner/src/cmdliner_term.ml", line 27, characters 19-24
Called from file "vendor/cmdliner/src/cmdliner.ml", line 106, characters 32-39
Called from file "vendor/cmdliner/src/cmdliner.ml", line 136, characters 18-36
Called from file "vendor/cmdliner/src/cmdliner.ml", line 251, characters 22-48
Called from file "bin/main.ml", line 1176, characters 10-51
$ ./_build/default/map_vs_hash.exe -ascii -quota 1 -clear-columns time speedup
sh: ./_build/default/map_vs_hash.exe: No such file or directory
</code></pre></div>

	<p>
	  We can make the speedup smaller or larger depending on the
	  details of the test; for example, it will vary with the
	  number of distinct keys. But overall, for code that is heavy
	  on sequences of querying and updating a set of key/value
	  pairs, hash tables will significantly outperform maps.</p>

	<p>
	  Hash tables are not always the faster choice, though. In
	  particular, maps excel in situations where you need to keep
	  multiple related versions of the data structure in memory at
	  once. That's because maps are immutable, and so operations
	  like <code>Map.add</code> that modify a map do so by
	  creating a new map, leaving the original
	  undisturbed. Moreover, the new and old maps share most of
	  their physical structure, so multiple versions can be kept
	  around efficiently.</p>

	<p>
	  Here's a benchmark that demonstrates this. In it, we
	  create a list of maps (or hash tables) that are built up by
	  iteratively applying small updates, keeping these copies
	  around. In the map case, this is done by using
	  <code>Map.change</code> to update the map. In the hash table
	  implementation, the updates are done using
	  <code>Hashtbl.change</code>, but we also need to call
	  <code>Hashtbl.copy</code> to take snapshots of the table:</p>

	<div class="highlight"><pre><code class="language-ocaml">open Core_kernel
open Core_bench

let create_maps ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0 then []
    else
      let new_map =
        Map.change map (i mod num_keys) ~f:(fun current -&gt;
          Some (1 + Option.value ~default:0 current))
      in
      new_map :: loop (i - 1) new_map
  in
  loop iterations Int.Map.empty

let create_tables ~num_keys ~iterations =
  let table = Int.Table.create ~size:num_keys () in
  let rec loop i =
    if i &lt;= 0 then []
    else (
      Hashtbl.change table (i mod num_keys) ~f:(fun current -&gt;
        Some (1 + Option.value ~default:0 current));
      let new_table = Hashtbl.copy table in
      new_table :: loop (i - 1)
    )
  in
  loop iterations

let tests ~num_keys ~iterations =
  let test name f = Bench.Test.create f ~name in
  [ test "table" (fun () -&gt; ignore (create_tables ~num_keys ~iterations))
  ; test "map"   (fun () -&gt; ignore (create_maps   ~num_keys ~iterations))
  ]

let () =
  tests ~num_keys:50 ~iterations:1000
  |&gt; Bench.make_command
  |&gt; Core.Command.run</code></pre></div>

	<p>
	  Unsurprisingly, maps perform far better than hash tables
	  on this benchmark, in this case by more than a factor of
	  10:</p>
  <div class="highlight"><pre><code class="language-ocaml">(executable ((name map_vs_hash2) (libraries (core_bench))))
</code></pre></div>
	<div class="highlight"><pre><code class="language-ocaml">$ jbuilder build map_vs_hash2.exe
Error: exception Sys_error("jbuild.inc: No such file or directory")
Backtrace:
Raised by primitive operation at file "pervasives.ml", line 389, characters 28-54
Called from file "src/io.ml", line 15, characters 11-31
Called from file "src/jbuild.ml", line 979, characters 22-71
Called from file "src/sexp.ml", line 339, characters 36-48
Called from file "list.ml", line 82, characters 20-23
Called from file "src/import.ml" (inlined), line 68, characters 31-41
Called from file "src/jbuild.ml", line 1005, characters 4-71
Called from file "src/jbuild.ml", line 1009, characters 6-63
Called from file "src/jbuild_load.ml", line 164, characters 33-64
Called from file "src/jbuild_load.ml", line 224, characters 23-44
Called from file "src/jbuild_load.ml", line 234, characters 16-58
Called from file "src/main.ml", line 26, characters 13-56
Called from file "bin/main.ml", line 547, characters 7-29
Called from file "vendor/cmdliner/src/cmdliner_term.ml", line 27, characters 19-24
Called from file "vendor/cmdliner/src/cmdliner.ml", line 106, characters 32-39
Called from file "vendor/cmdliner/src/cmdliner.ml", line 136, characters 18-36
Called from file "vendor/cmdliner/src/cmdliner.ml", line 251, characters 22-48
Called from file "bin/main.ml", line 1176, characters 10-51
$ ./_build/default/map_vs_hash2.exe -ascii -clear-columns time speedup
sh: ./_build/default/map_vs_hash2.exe: No such file or directory
</code></pre></div>

	<p>
	  These numbers can be made more extreme by increasing the
	  size of the tables or the length of the list.</p>

	<p>
	  As you can see, the relative performance of trees and maps
	  depends a great deal on the details of how they're used, and so
	  whether to choose one data structure or the other will depend on
	  the details of the application.

	  <a data-type="indexterm" data-primary="phys_equal function">&nbsp;</a>
	  <a data-type="indexterm" data-primary="equal equal (= =) operator">&nbsp;</a>
	  <a data-type="indexterm" data-primary="equal (=) operator">&nbsp;</a>
	  <a data-type="indexterm" data-primary="structural equality">&nbsp;</a>
	  <a data-type="indexterm" data-primary="physical equality">&nbsp;</a>
	  <a data-type="indexterm" data-primary="equality, tests of">&nbsp;</a></p>
      </section>
    </section>
  </article></div><a class="next-chapter" href="14-command-line-parsing.html"><div class="content"><h1><small>Next: Chapter 14</small>Command-Line Parsing</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script><script src="js/discourse.js"></script></body></html>